#include<iostream>
#include"taxi_header_use.h"
#include"taxi_init.h"
using namespace std;
/*函数功能1文件格式说明：
样例如下:
2720 (对应存入的出租车数量,对应了功能1的要求)
9, 116.52773, 40.04120, 5, 20, 28, 18   (从左到右依次对应出租车序号名,点的空间经纬度,时间)
12, 116.56995, 40.06335, 5, 20, 29, 27
12, 116.56794, 40.06370, 5, 20, 30, 12
...... (一直到文件结束都是点的信息,体现了矩形内轨迹点的全部情况)
*/

/*函数功能2文件格式说明：
样例如下:
18   (对应了分析的时间段数量,如要分析180分钟,每10分钟作为一段的长度,这里就是18,对应了数量)
0,0  (该处为r的数组下表,也就是北京城被分割成格子后格子的数组名称,如本处的0,0表示北京城最左上角)
0,0  (前者表示是分析的时间段第几条,后者表示此段时该空间内有多少出租车)
1,0
2,0
3,0
4,0
5,0
6,0
7,0
8,0
9,0
10,0
11,0
12,0
13,0
14,0
15,0
16,0 
17,0  (0-17刚好对应了18段时间段)
...
32,54 (32,54下表所对应的格子位置)
0,0
1,0   (前两段无出租车)
2,1,8877  (第三段对应了一辆出租车,序号名为8877)
3,1,7253
4,2,1844,7464 (第五段对应了两辆出租车,序号名为1844和7464,其他类推即可,这样就能看到变化了)
5,0
6,1,1689
7,0
8,1,3262
9,1,3262
10,3,5537,3262,7920
11,1,3262
12,0
13,0
14,0
15,0
16,0
17,1,6470
......
podr,41,3,1,3,0,1,1,1,1,2,0,1,3,3,0,1,4,2 (podr说明北京内的分析已经结束了,后面分别对应了北京外的1-18时间段的出租车数量,如41表示第一段的在北京外的出租车数量)
*/

/*函数功能3文件格式说明：
346 (对应存入的出租车数量,对应了功能3车流量的要求)
129,116.54070,40.05670,5,12,9,42  (从左到右依次对应出租车序号名,点的空间经纬度,时间)
129,116.54823,40.06286,5,12,10,26
129,116.47826,40.10732,5,15,7,47
129,116.47875,40.11118,5,15,8,2
129,116.64484,40.27242,5,15,22,52
...... (一直到文件结束都是点的信息,体现了车流交换的全部情况)
*/

/*函数功能4文件格式说明：
17  (对应存入的出租车数量,对应了功能3车流量的要求,这里没有详细分析变化,但是有要求可以实现)
509,116.65463,40.21080,3,12,28,2  (从左到右依次对应出租车序号名,点的空间经纬度,时间)
509,116.62853,40.24570,3,12,34,2
509,116.62972,40.24648,3,12,41,24
509,116.65060,40.21103,3,12,47,24
...... (一直到文件结束都是点的信息,体现了车流量的交换的全部情况)
*/

/*函数功能5文件格式说明：
10  (对应了前K条路径的K,如果要求长度很高不够K条的话,这里就不是10,而是实际的有效数量)
116.579,40.046,116.586,40.078,252,2834.72458  (路径,从左到右为结点1的经纬度,2的经纬度,
116.579,40.047,116.586,40.078,240,2752.91770   路径本身的频繁度,以及路径的实际长度,单位为m)
116.563,40.064,116.582,40.062,191,2119.56109
116.579,40.046,116.586,40.077,165,2752.91770
....... (有效路径的全部展示)
*/

/*函数功能6文件格式说明：
10  (对应了前K条路径的K,如果要求长度很高不够K条的话,这里就不是10,而是实际的有效数量)
116.529,40.044,116.728,40.298,33424,30947.5 (路径,从左到右为结点1的经纬度,2的经纬度,
116.529,40.044,116.699,40.346,2251,31923     路径本身的频繁度,以及路径的实际长度,单位为m)
116.568,40.063,116.638,40.32,1747,23233.9
116.568,40.063,116.631,40.33,1491,23797.6
....... (有效路径的全部展示)
*/
//neighbor同理,但是只展示相邻时间点的有效信息(上面的轨迹点构成的边可以隔着其他轨迹点)

/*函数功能7文件格式说明：
769 (指出两个矩形间的路径最短时间)
3745,116.47876,40.11039,2,20,1,24  (从起点开始展示了轨迹点的信息,依次为序号名,经纬度,时间)
3745,116.48123,40.16708,2,20,4,39
3745,116.48505,40.18837,2,20,5,55
3745,116.51740,40.23105,2,20,8,46
3745,116.53142,40.24252,2,20,9,40
3745,116.56860,40.25823,2,20,11,27
3745,116.58029,40.26117,2,20,11,59
3745,116.58029,40.26117,2,20,11,59
3745,116.62947,40.27301,2,20,14,13 (直到终点结束)
*/

int main()
{
	//出租车序列化测试
	//for(int i=1000;i<11000;i+=1000)
	//boost_archive_taxi2(i);

	//出租车反序列化测试
	//for (int i = 2; i <= 1000; i += 100) 
	//{
	//	taxi temp = boost_iarchive_taxi2(i);
	//	temp.printtaxi_track();
	//}
	
	//时间分布类序列化测试
	//for (int i = 2; i <= 7; i +=3){
	//	boost_archive_time2(i,3);
	//}
	//boost_archive_time2(8, 1);

	//时间分布类反序列化测试
	/*for(int i=6;i<=8;i++)
	{
		for(int j=0;j<=23;j+=3)
			for (int k = 0; k <= 59; k += 10) 
			{
				time_distribution t = boost_iarchive_time(i, j, k);
				t.print_time_distribution();
			}
	}*/

	//空间分布类序列化测试
	//boost_archive_position_in2();
	//空间分布反序列化测试
	//for(double d=inBeijing_Longitude_min;d< inBeijing_Longitude_max;d+=0.10)
	//{
	//	for(double dd= inBeijing_Latitude_min;dd<inBeijing_Latitude_max;dd+=0.10)
	//	{
	//		position_distribution_inBeiJing temp = boost_iarchive_position_in2(d, dd);
	//		temp.print_position_distribution_inBeiJing();
	//	}
	//}

	//空间分布北京外序列化测试
	//boost_archive_position_out2();
	//反序列化测试
	//position_distribution_outBeiJing temp = boost_iarchive_position_out2();
	//temp.print_position_distribution_outBeiJing();

	//路径类序列化测试
	/*pathgraph p;
	boost_pathserialization_iarchive(p);
	p.pathserialization2();*/

	//反序列化测试：
	//pathgraph p;
	//boost_pathserialization_iarchive2(p);
	//p.getpathEdgemap();

	//double pos1[4] = { 116.6133,116.7321,40.234,40.444 };
	//double pos2[4] = { 116.4612,116.571,40.034,40.144 };
	////函数功能1测试
	//set<Point, CMP> s1;
	//set<Point, CMP> s2;
	//int counttaxi1 = function_findtaxinum_somewhere(s1, pos1, 4, 0, 0, 24 * 60);
	//cout << "---------------------" << endl;
	//int counttaxi2 = function_findtaxinum_somewhere(s2, pos2, 5, 0, 0, 24 * 60);
	
	//函数功能2测试
	//function_regional_density_analysis(5, 5, 12, 0, 1 * 60);
	//function_regional_density_analysis(20, 6, 12, 0, 3 * 60);
	//函数功能3测试
	//function_region_association_analysis_one(pos1, pos2, 5, 0, 0, 24 * 60);
	
	//函数功能4测试
	//function_region_association_analysis_two(pos1, 3, 12, 0, 2 * 60);

	//函数功能5测试
	//function_path_frequent_analysis1(2000, 10);
	
	//函数功能6测试
	//function_path_frequent_analysis2(pos1,pos2,10);
	//cout << "-------------------------------------" << endl;	
	
	//函数功能6相邻点版本测试
	//function_path_frequent_analysis2_neighbor(pos1, pos2, 10);
	
	//函数功能7测试
	//vector<Point> result =function_pathuse_shortesttime(pos1,pos2,2,0,0,1*24*60);
	//for (auto i : result) 
	//{
	//	i.printPoint();
	//}
	return 0;	
}